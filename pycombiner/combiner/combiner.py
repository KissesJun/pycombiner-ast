"""
Main module for PyCombiner
"""
from pathlib import Path
from typing import Dict, List, Set, Tuple
import ast
import re
from .output import MergeReport, print_merge_report

class PyCombiner:
    def __init__(self, entry_file: Path, source_dir: Path, output_file: Path, debug: bool = False, show_details: bool = False):
        self.entry_file = entry_file
        self.source_dir = source_dir
        self.output_file = output_file
        self.debug = debug
        self.show_details = show_details
        self.report = MergeReport(entry_file, source_dir, output_file, debug, show_details)
        self.imports_by_file: Dict[str, List[str]] = {}
        self.dependency_graph: Dict[str, Set[str]] = {}
        self.merge_order: List[Path] = []
        self.stats = {
            'total_imports': 0,
            'duplicate_imports': 0,
            'redundant_imports': 0,
            'total_lines': 0,
            'functions': 0,
            'classes': 0
        }

    def debug_print(self, message: str):
        """Print debug message if debug mode is enabled"""
        if self.debug:
            print(f"[DEBUG] {message}")

    def _is_relative_import(self, import_path: str) -> bool:
        """Check if an import is relative to the source directory"""
        try:
            import_path = import_path.replace('.', '/')
            if import_path.endswith('.py'):
                import_path = import_path[:-3]
            (self.source_dir / import_path).resolve().relative_to(self.source_dir)
            return True
        except (ValueError, FileNotFoundError):
            return False

    def _get_import_path(self, import_path: str) -> Path:
        """Convert import path to file path"""
        import_path = import_path.replace('.', '/')
        if not import_path.endswith('.py'):
            import_path += '.py'
        return self.source_dir / import_path

    def _parse_imports(self, file_path: Path) -> Tuple[Set[str], Set[str]]:
        """Parse imports from a Python file"""
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        try:
            tree = ast.parse(content)
        except SyntaxError as e:
            self.debug_print(f"Syntax error in {file_path}: {e}")
            return set(), set()

        imports = set()
        unhandled_imports = set()

        for node in ast.walk(tree):
            if isinstance(node, (ast.Import, ast.ImportFrom)):
                if isinstance(node, ast.Import):
                    for name in node.names:
                        import_path = name.name
                        if self._is_relative_import(import_path):
                            imports.add(import_path)
                        else:
                            unhandled_imports.add(import_path)
                else:  # ImportFrom
                    if node.module:
                        if self._is_relative_import(node.module):
                            imports.add(node.module)
                        else:
                            unhandled_imports.add(node.module)

        return imports, unhandled_imports

    def _build_dependency_graph(self):
        """Build dependency graph between files"""
        for file_path in self.source_dir.rglob('*.py'):
            imports, _ = self._parse_imports(file_path)
            self.dependency_graph[str(file_path)] = set()
            for imp in imports:
                imp_path = self._get_import_path(imp)
                if imp_path.exists():
                    self.dependency_graph[str(file_path)].add(str(imp_path))

    def _get_merge_order(self) -> List[Path]:
        """Get the order to merge files based on dependencies"""
        visited = set()
        order = []

        def visit(file_path: str):
            if file_path in visited:
                return
            visited.add(file_path)
            for dep in self.dependency_graph.get(file_path, set()):
                visit(dep)
            order.append(Path(file_path))

        # Start with entry file
        visit(str(self.entry_file))

        # Add any remaining files
        for file_path in self.source_dir.rglob('*.py'):
            if str(file_path) not in visited:
                visit(str(file_path))

        return order

    def _merge_files(self):
        """Merge all Python files in the correct order"""
        with open(self.output_file, 'w', encoding='utf-8') as out:
            # Write header
            out.write(f"# Generated by PyCombiner\n")
            out.write(f"# Entry file: {self.entry_file}\n")
            out.write(f"# Source directory: {self.source_dir}\n\n")

            # Track imports to avoid duplicates
            all_imports = set()
            local_imports = set()

            # First pass: collect all imports
            for file_path in self.merge_order:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()

                try:
                    tree = ast.parse(content)
                except SyntaxError as e:
                    self.debug_print(f"Syntax error in {file_path}: {e}")
                    continue

                # Process imports
                for node in ast.iter_child_nodes(tree):
                    if isinstance(node, (ast.Import, ast.ImportFrom)):
                        if isinstance(node, ast.Import):
                            for name in node.names:
                                import_path = name.name
                                if self._is_relative_import(import_path):
                                    local_imports.add(import_path)
                                else:
                                    all_imports.add(f"import {import_path}")
                        else:  # ImportFrom
                            if node.module:
                                if self._is_relative_import(node.module):
                                    local_imports.add(node.module)
                                else:
                                    all_imports.add(f"from {node.module} import {', '.join(n.name for n in node.names)}")

            # Write all imports at the beginning
            for imp in sorted(all_imports):
                out.write(imp + '\n')
            out.write('\n')

            # Write local imports
            for imp in sorted(local_imports):
                out.write(f"import {imp}\n")
            out.write('\n')

            # Second pass: write file contents
            for file_path in self.merge_order:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()

                try:
                    tree = ast.parse(content)
                except SyntaxError as e:
                    self.debug_print(f"Syntax error in {file_path}: {e}")
                    continue

                # Write file header
                out.write(f"\n#{'='*80}\n")
                out.write(f"# File: {file_path}\n")
                out.write(f"#{'='*80}\n\n")

                # Write non-import statements
                for node in ast.iter_child_nodes(tree):
                    if isinstance(node, (ast.Import, ast.ImportFrom)):
                        continue  # Skip import statements
                    elif isinstance(node, (ast.FunctionDef, ast.ClassDef)):
                        if isinstance(node, ast.FunctionDef):
                            self.stats['functions'] += 1
                        else:
                            self.stats['classes'] += 1
                        out.write(ast.unparse(node) + '\n\n')
                    elif isinstance(node, ast.If) and isinstance(node.test, ast.Compare):
                        # Check if this is an if __name__ == "__main__" block
                        if (isinstance(node.test.left, ast.Name) and 
                            node.test.left.id == "__name__" and 
                            isinstance(node.test.ops[0], ast.Eq) and 
                            isinstance(node.test.comparators[0], ast.Constant) and 
                            node.test.comparators[0].value == "__main__"):
                            out.write(ast.unparse(node) + '\n\n')

    def combine(self):
        """Combine all Python files into a single file"""
        self.debug_print("Starting file combination process...")
        
        # Build dependency graph
        self.debug_print("Building dependency graph...")
        self._build_dependency_graph()
        self.report.set_dependency_graph(self.dependency_graph)

        # Get merge order
        self.debug_print("Determining merge order...")
        self.merge_order = self._get_merge_order()
        self.report.set_merge_order(self.merge_order)

        # Process each file for report
        self.debug_print("Processing files...")
        for file_path in self.merge_order:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = len(f.readlines())
            self.report.add_file_info(file_path, lines, set(), set())  # Empty sets as imports are handled in _merge_files

        # Merge files
        self.debug_print("Merging files...")
        self._merge_files()

        # Update report
        self.debug_print("Updating report...")
        self.report.update_stats(self.stats)

        # Print report
        self.debug_print("Printing report...")
        print_merge_report(self.report) 